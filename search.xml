<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Simhash的生成及存储]]></title>
    <url>%2F2018%2F03%2F06%2Fperday%2Fsimhash%2F</url>
    <content type="text"><![CDATA[背景介绍 根据 Detecting Near-Duplicates for Web Crawling 论文中的介绍，在互联网中有很多的网页的内容是一样的，但是他们的网页元素却不是完全相同的，每个域名下的网页总会有一些自己的东西，比如广告、导航栏、网站版权之类的东西，但是对于搜索引擎来讲，只有内容部分才是有意义的，而后面的那些虽然不同，但是对搜索结果没有任何影响，所以在判定内容是否重复的时候，应该忽视后面的部分，当新爬取的内容和数据库中的某个网页的内容一样的时候，就称其为Near-Duplicates（重复文章）。对于重复文章，不应在执行入库操作，这种操作的优点是(A)节省带宽、(B)节省磁盘、(C)减轻服务器负荷以及(D)去除相似文章噪点干扰，提升索引的质量。 在现实中，一模一样的网页的概率是很小的，大部分的相似网页都会存在一些细节的变化，而如何进行这种判定就是一个本文要解决的一个问题。除了近似文章判定算法的难题，还有以下待解决的难点（按照80亿篇文章来考虑）： 数据规模巨大，对于海量数据如何存储 查找速度，如何做到在毫秒级别返回检索结果 simhash介绍 simhash是由 Charikar 在2002年提出来的,它是一种能计算文档相似度的hash算法，google用它来出来海量的文本去重工作。simhash属于局部敏感型（locality sensitive hash）的一种，其主要思想是降维，将高维的特征向量转化成一个f位的指纹（fingerprint），通过两个得出指纹的海明距离（hamming distince）来确定两篇文章的相似度，海明距离越小，相似度越低，根据 Detecting Near-Duplicates for Web Crawling 论文中所说，一般海明距离为3就代表两篇文章相同。 simhash也有其局限性，在处理小于500字的短文本时simhash的表现并不是很好，所以在使用simhash前一定要注意这个细节。 simhash与hash算法的区别 传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。 我们主要解决的是文本相似度计算，要比较的是两个文章是否相识，当然我们降维生成了hash签名也是用于这个目的。看到这里估计大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。我们可以来做个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦，回家罗回家罗” 和 “你妈妈叫你回家吃饭啦，回家罗回家罗”。 通过simhash计算结果为： 1000010010101101111111100000101011010001001111100001001011001011 1000010010101101011111100000101011010001001111100001101010001011 通过传统hash计算为： 0001000001100110100111011011110 1010010001111111110010110011101大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希的魅力。 simhash的生成simhash的生成图解如下图：为了更加通俗易懂，采用例子来详解simhash的生成规则。simhash的生成划分为五个步骤：分词-&gt;hash-&gt;加权-&gt;合并-&gt;降维 1：分词，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。 2：hash，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。 3：加权，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。 4：合并，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。 5：降维，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。 整个过程的流程图为： simhash分表存储策略在线上查询算法中，首先建立多个指纹表:T1，T2，√…，Tt。每个指纹表 Ti 关联两个未知数：一个整型pi和一个在f bit-positions上的排列πi,Ti就是对已经存在的所有指纹进行排列πi得到的有序集合。对于一个指纹f和一个整数k，算法分两个步骤： 1 找到Ti中所有的前pi个bit-positions和πi（F）的前pi个bit-positions相同的指纹，假设为指纹集合F 2 在F中的每一个指纹，比较其是否和πi（F）有的差异不超过k个 分表存储原理借鉴hashmap算法找出可以hash的key值，因为我们使用的simhash是局部敏感哈希，这个算法的特点是只要相似的字符串只有个别的位数是有差别变化。那这样我们可以推断两个相似的文本，至少有16位的simhash是一样的。 分表存储设计假设f = 64 ，k=3，并且我们有80亿 = 2^34个数的网页指纹，d=34，可以有下面四种设计方法 （f：指纹位数，k：海明距离，d：将文章数量转化成2的幂次方，d就是幂值） 1.20个表：将64bit分为11,11,11,11,10,10六个bit块.根据排列组合，如果想从这6个块中找3个作为leading bits的话（这样才能满足|pi-d|是个小整数），一共有C(6,3)=20种找法，所以需要20个表，每个表的前三块来自不同的三个块，那么pi就有11+11+11、11+ 11+10和11+10+10三种可能了。一次嗅探平均需要检索2^(34-31)=8个指纹2.16个表：先将64bit均分成4份，然后对每份，将剩馀了48bit，再均分成四份，也就是16,12,12,12,12,12五部分，很明显这种组合的可能是4*4，而pi = 28。一次嗅探平均需要检索2^(34-28)=64个指纹3.10个表：将65bit分成 13，13，13，13，12 五个bit快。根据排列组合，需要从5块中找到2个作为leading bits，共有C(5,2)=10种找法，需要10张表，而pi=25或26。一次嗅探平均需要检索2^(34-25)=512个指纹4.4个表：同理 64 等分为4份，每份16bit，从四份中找出1个leading bits，共有C(4,1)=10种找法，pi=16,一次嗅探平均需要检索2^(34-16)=256K个指纹 分表存储实现存储： 1、将一个64位的simhash签名拆分成4个16位的二进制码。（图上红色的16位） 2、分别拿着4个16位二进制码查找当前对应位置上是否有元素。（放大后的16位） 3、对应位置没有元素，直接追加到链表上；对应位置有则直接追加到链表尾端。（图上的 S1 — SN） 查找： 1、将需要比较的simhash签名拆分成4个16位的二进制码。 2、分别拿着4个16位二进制码每一个去查找simhash集合对应位置上是否有元素。 3、如果有元素，则把链表拿出来顺序查找比较，直到simhash小于一定大小的值，整个过程完成。 原理： 借鉴hashmap算法找出可以hash的key值，因为我们使用的simhash是局部敏感哈希，这个算法的特点是只要相似的字符串只有个别的位数是有差别变化。那这样我们可以推断两个相似的文本，至少有16位的simhash是一样的。具体选择16位、8位、4位，大家根据自己的数据测试选择，虽然比较的位数越小越精准，但是空间会变大。分为4个16位段的存储空间是单独simhash存储空间的4倍。之前算出5000w数据是 382 Mb，扩大4倍1.5G左右，还可以接受 最佳分表策略根据 4.2节分表存储设计，给定 f,k 我们可以有很多种分表的方式，增加表的个数会减少检索时间，但是会增加内存的消耗，相反的，减少表的个数，会减少内存的压力，但是会增加检索时间。根据google大量的实验，存在一个分表策略满足时间和空间的平衡点τ=d-pi （pi计算看4.2章节，取最小pi） simhash存储实现(Go)国外有一大神用go实现了d=3和6的实现，在他的基础上我实现了d到8的扩展，源码请看https://github.com/kricen/shstorage 参考文章 论文 Detecting Near-Duplicates for Web Crawling http://www.cnblogs.com/maybe2030/p/5203186.html]]></content>
      <categories>
        <category>每日进步一点点</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Simhash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Restful架构的理解及使用场景分析]]></title>
    <url>%2F2018%2F03%2F05%2Fperday%2Frestful%2F</url>
    <content type="text"><![CDATA[理解Restful架构REST的由来 在互联网行业，实践总是走在理论的前列。Web发展至今，面向静态文档的HTTP/1.0协议已经无法满足Web应用的开发需求，因此需要设计新版本的HTTP协议。当前的发展趋势，前端设备层出不穷，因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。Roy Fielding(Apache软件基金会的合作创始人) 在他的博士学位论文Architectural Styles and the Design of Network-based Software Architectures中，Fielding更为系统、严谨地阐述了这套理论框架，并且使用这套理论框架推导出了一种新的架构风格，并且为这种架构风格取了一个令人轻松愉快的名字“REST”——Representational State Transfer（表述性状态转移）的缩写。 Rest架构风格最重要的架构约束 客户-服务器（Client-Server）：通信只能由客户端单方面发起，表现为请求-响应的形式。 无状态（Stateless）：通信的会话状态（Session State）应该全部由客户端负责维护。 缓存（Cache）：响应内容可以在通信链的某处被缓存，以改善网络效率。 统一接口（Uniform Interface）：通信链的组件之间通过统一的接口相互通信，以提高交互的可见性。 分层系统（Layered System）：通过限制组件的行为（即，每个组件只能“看到”与其交互的紧邻层），将架构分解为若干等级的层。 按需代码（Code-On-Demand，可选）：支持通过下载并执行一些代码（例如Java Applet、Flash或JavaScript），对客户端的功能进行扩展。 REST详解 如果深入理解REST，需要理解REST的五个关键词 资源（Resource） 资源的表述（Representation） 状态转移（State Transfer） 统一接口（Uniform Interface） 超文本驱动（Hypertext Driven） 什么是资源？资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 什么是资源的表述？资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 什么是状态转移？状态转移（state transfer）与状态机中的状态迁移（state transition）的含义是不同的。状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 什么是统一接口？REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。以HTTP/1.1协议为例，HTTP/1.1协议定义了一个操作资源的统一接口，主要包括以下内容： 7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS HTTP头信息（可自定义） HTTP响应状态代码（可自定义） 一套标准的内容协商机制 一套标准的缓存机制 一套标准的客户端身份认证机制 REST还要求，对于资源执行的操作，其操作语义必须由HTTP消息体之前的部分完全表达，不能将操作语义封装在HTTP消息体内部。这样做是为了提高交互的可见性，以便于通信链的中间组件实现缓存、安全审计等等功能。 什么是超文本驱动？“超文本驱动”又名“将超媒体作为应用状态的引擎”（Hypermedia As The Engine Of Application State，来自Fielding博士论文中的一句话，缩写为HATEOAS）。将Web应用看作是一个由很多状态（应用状态）组成的有限状态机。资源之间通过超链接相互关联，超链接既代表资源之间的关系，也代表可执行的状态迁移。在超媒体之中不仅仅包含数据，还包含了状态迁移的语义。以超媒体作为引擎，驱动Web应用的状态迁移。通过超媒体暴露出服务器所提供的资源，服务器提供了哪些资源是在运行时通过解析超媒体发现的，而不是事先定义的。从面向服务的角度看，超媒体定义了服务器所提供服务的协议。客户端应该依赖的是超媒体的状态迁移语义，而不应该对于是否存在某个URI或URI的某种特殊构造方式作出假设。一切都有可能变化，只有超媒体的状态迁移语义能够长期保持稳定。 Rest风格6个的主要特征 面向资源（Resource Oriented） 可寻址（Addressability） 连通性（Connectedness） 无状态（Statelessness） 统一接口（Uniform Interface） 超文本驱动（Hypertext Driven） REST架构风格可以为Web开发者带来三方面的利益： 简单性采用REST架构风格，对于开发、测试、运维人员来说，都会更简单。可以充分利用大量HTTP服务器端和客户端开发库、Web功能测试/性能测试工具、HTTP缓存、HTTP代理服务器、防火墙。这些开发库和基础设施早已成为了日常用品，不需要什么火箭科技（例如神奇昂贵的应用服务器、中间件）就能解决大多数可伸缩性方面的问题。 可伸缩性充分利用好通信链各个位置的HTTP缓存组件，可以带来更好的可伸缩性。其实很多时候，在Web前端做性能优化，产生的效果不亚于仅仅在服务器端做性能优化，但是HTTP协议层面的缓存常常被一些资深的架构师完全忽略掉。 松耦合统一接口+超文本驱动，带来了最大限度的松耦合。允许服务器端和客户端程序在很大范围内，相对独立地进化。对于设计面向企业内网的API来说，松耦合并不是一个很重要的设计关注点。但是对于设计面向互联网的API来说，松耦合变成了一个必选项，不仅在设计时应该关注，而且应该放在最优先位置。 Restful API设计在 REST 提出多年来，当前对于 REST 风格的应用最多的即是 Restful API 。Restful API 一般分为对外和对内。对外的 Restful API 为面向公网的公共服务接口，此类接口一般可以通过公网直接访问，或是经过一定的安全认证后通过公网访问。而对内的 Restful API 则主要是一整套系统内部各个子系统或模块之间交互的标准接口，相对于对外的 Restful API 接口，内部 API 接口更加标准化。按照 REST 的要求，Restful API 的设计可以总结出以下的一些具体要求。 HTTPS + 域名Restful API 的无状态性，要求客户端需要在调用接口时传入足够的信息以供服务端用于操作指定的资源，这就有可能使得接口数据在网络传输过程中遭到拦截导致更多的数据泄漏。因此在提供 Restful API ，特别是对外的 API 时，应当尽可能的使用 HTTPS 协议，以确保传输过程的安全。 另一方面，在 API 地址中使用域名，可以进一步解耦服务端与客户端，服务端可以更加容易的迁移和扩展，而不会影响服务端的使用。 实际应用过程中，使用 HTTPS 协议，更多应用与对外的 Restful API 接口，而对内网的 Restful API 来说，可以在信任内网安全的前提下，使用 HTTP 协议，以降低复杂度，提高效率。 URL 指向资源，HTTP 动词指向操作按照 REST 的要求，Restful API 的 URL 地址应指向具体的一个资源，例如用户 user 。URL 中应当只包含资源名词，不应该包含指向操作的动词，例如新建、查询、修改、删除等。具体操作通过 HTTP 动词（ GET / POST / PUT / DELETE ）指定。 指定 API 版本号在设计 Restful API 时，特别是对外的 API ，通常需要考虑 API 多版本的问题，因为 API 会进行升级，而客户端则处于不可控状态，可能无法及时对 API 调用过程进行配合升级。因此，服务端需要提供对不同版本 API 的支持，同时，客户端在调用 API 时也需要指定特定的版本号，以确保调用过程正常进行。 版本号的指定，可以在 URL 中，也可以在 HTTP 头信息中。 指定参数在 Restful API 请求中，可能需要根据不同的情况进行过滤，需要增加操作参数。一般来说，针对 GET 和 DELTE 请求需要增加操作参数的情况较多，而 POST 和 PUT 更多的是通过 HTTP 报文体提供操作数据信息。 指定参数可以通过两种方式：URL 地址参数和 ? 参数。例如12345// URL 地址参数https://open.domain.com/app/user/123456/Admin//? 参数https://open.domain.com/app/user?id=123456&amp;type=Admin 使用 JSON 作为返回数据格式例如：12345// JSON 格式&#123;"name":"user","type":"Admin"&#125;// XML 格式&lt;user&gt;&lt;name&gt;user&lt;/name&gt;&lt;type&gt;Admin&lt;/type&gt;&lt;/user&gt; 使用安全认证机制在使用 Restful API ，特别是对公网开放的 Restful API，通常需要通过一定的安全认证机制来进行实现访问控制。目前主流的方案是通过 OAuth2.0 实现安全认证。 Restful API 使用场景根据 Restful API 的特定，其应用场景可以参考以下的场景： 资源集中型服务，例如针对用户的信息查询，针对订单的信息查询的等，这类型服务以资源实体为中心，操作大多为简单的 CRUD 操作，业务逻辑简单。 访问量大，且对访问时效要求比较高的服务。Restful API 相对于 SOAP WebService 来说，数据量更小，解析更快，在网络环境下能够提高访问的速度和承载能力。 面向公网的，且安全性要求较低的开放型 API 服务。这类服务通常由开发者向公网的所有使用者开放，Restful API 的形式能够简化服务调用过程，提高访问效率。 对于复杂业务操作，例如保全申请提交，理赔申请提交等，使用 Restful API 形式难以进行设计，因此此类的业务可以使用传统 RPC 的接口形式进行设计，SOAP WebService 或者 HTTP/JSON 形式的 RPC 都是可行的选择，使用 RPC 形式反而会更加简单。 Restful API 优势Restful API 充分利用了 HTTP 协议的设计，使用面向资源的接口设计，相对于传统 RPC 降低了接口设计的复杂度。 例如，使用传统 RPC 形式设计针对用户对象的 CRUD 操作：123456789101112// 新建用户https://open.domain.com/app/addUser// 查询用户https://open.domain.com/app/retrieveUser// 更新用户https://open.domain.com/app/updateUser// 删除用户https://open.domain.com/app/deleteUser在以上实例中，需要通过四个 URL 来实现 CRUD 操作。而通过 Restful API 设计，可为如下实例：// GET: 查询用户；POST: 新建用户；PUT: 更新用户；DELETE: 删除用户https://open.domain.com/app/user 在以上实例中，通过 HTTP 动词指定了不同的 CRUD 操作，将接口 URL 简化为了同一个地址，仅需要改变 HTTP 动词即可实现不同的操作。 另一方面，相对于 SOAP/XML 形式的 RPC 服务，Restful API 采用 HTTP/JSON 的形式传递数据，降低了传输数据量，同时提高了数据解析的效率，单位时间内的负载能力会高于 SOAP WebService 服务。 例如，对于 SOAP WebService 来说，基本的请求响应格式如下：123456&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body&gt; &lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 而对于 Restful API 来说，其请求格式符合 HTTP 协议的要求，返回格式则符合标准的 JSON 格式即可。 Restful API 劣势Restful API 面向资源设计接口，而对于一些复杂操作来说，接口设计难度将远大于 RPC 形式。 例如，用户登录验证，使用 RPC 形式设计接口如下： https://open.domain.com/app/checkUser 在以上实例中，对于 Restful API 而言，很难将该业务归类为 HTTP 动词中的某一种。又比如“下单”这一功能，它涉及到了订单、用户、支付账户等多个资源实体的多种操作，因此同样也难以设计为 Restful API 。 Restful API 具备高效简洁的特点，但这也因此造成 Restful API 没有类似于 SOAP 协议的规范性协议，Restful API 中的数据格式、标准、安全性等都需要由开发者决定，这也就造成了无法建立统一的 Restful API 标准，作为客户端可能需要适配多种格式的 Restful API 。 选择哪种方式的接口设计，需要根据实际的应用情况进行调整，没有最好的，只有最合适的 参考文章 https://segmentfault.com/a/1190000006735330 http://www.infoq.com/cn/articles/understanding-restful-style]]></content>
      <categories>
        <category>每日进步一点点</category>
      </categories>
      <tags>
        <tag>Restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[insert+where特殊场景的解决方案]]></title>
    <url>%2F2017%2F07%2F05%2FsqlInsertWithSelect%2F</url>
    <content type="text"><![CDATA[在数据库插入的场景中，我们可能会遇见这种情况：检测数据库是否含有即将要写入的数据。比如 province（省份）包含一个唯一字段:name,以往的做法是: 1:先执行一句查询的sql语句 1select * from province where name=&apos;?&apos; 2:如果这条数据不存在，再执行插入语句1insert into province(name) values(&apos;?&apos;) 虽然说上面的方法能够完成这样的场景，但是不够优雅！所以我在想，有没有一个好的办法能够解决这样的问题呢？于是，我联想到几条sql语句 把当前时间转化成特定格式的字符串1select to_char(to_timestamp(extract(epoch from now() )::integer), 'YYYY-MM-DD') 把代处理表中的数据插入到新表中1insert province (name) select name from pendding_province_list 于是，我开始着手改造insert插入语句12insert into province (name) select &apos;?&apos; where not exists (select * from province where name=&apos;?&apos;) 完美！]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>